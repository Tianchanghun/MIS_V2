# 엑셀 일괄 업로드 시스템

## 📋 개요

MIS v2의 엑셀 일괄 업로드 시스템은 동적 분류 관리 시스템과 완전히 연동되어, 분류 정보의 추가/삭제에 실시간으로 대응하는 확장 가능한 업로드 시스템입니다.

## 🌟 핵심 특징

### 1. 완전 동적 분류 지원
- **자동 분류 감지**: 코드 관리의 CST 하위 분류 자동 인식
- **실시간 반영**: 새로운 분류 추가 시 즉시 업로드 지원
- **유연한 입력**: 분류 코드 또는 분류명 모두 입력 가능
- **검증 시스템**: 유효하지 않은 분류값 자동 감지 및 오류 리포트

### 2. 스마트 업로드 처리
- **UPSERT 로직**: 기존 데이터 업데이트, 신규 데이터 삽입
- **오류 허용**: 일부 행 오류 시에도 나머지 데이터 처리 계속
- **상세 리포트**: 성공/실패 건수 및 오류 상세 내역 제공
- **대용량 지원**: 10MB 이하 파일, 5분 타임아웃 지원

## 🏗️ 시스템 아키텍처

### 1. 다운로드 단계 (템플릿 생성)
```
코드 관리 시스템
        ↓
CST 하위 분류 동적 조회
        ↓
엑셀 헤더 동적 구성
        ↓
매장 데이터 + 분류코드정보 시트 생성
        ↓
사용자 다운로드
```

### 2. 업로드 단계 (데이터 처리)
```
엑셀 파일 업로드
        ↓
헤더 분석 및 필수 컬럼 검증
        ↓
분류 정보 동적 매핑
        ↓
행별 데이터 처리 (UPSERT)
        ↓
분류값 유효성 검증
        ↓
결과 리포트 생성
```

## 🔧 API 구현

### 1. 동적 엑셀 다운로드 API

#### `/shop/api/export-excel` - 개선된 다운로드
```python
@shop_bp.route('/api/export-excel')
def api_export_excel():
    """매장 정보 엑셀 다운로드 API - 동적 분류 완전 반영"""
    
    # 현재 동적 분류 정보 조회
    classifications = {}
    classification_headers = []
    
    # CST 그룹 찾기
    cst_group = Code.query.filter_by(code='CST', depth=0).first()
    if cst_group:
        # CST 하위의 모든 분류 그룹들을 동적으로 조회
        classification_groups = Code.query.filter_by(
            parent_seq=cst_group.seq, 
            depth=1
        ).order_by(Code.sort.asc()).all()
        
        for group in classification_groups:
            group_key = group.code.lower()
            classifications[group_key] = {
                'code': group.code,
                'name': group.code_name,
                'field_name': get_field_mapping(group_key)  # 동적 필드 매핑
            }
            classification_headers.append(group.code_name)
    
    # 동적 헤더 구성 (기본 정보 + 동적 분류)
    base_headers = [
        "거래처코드", "거래처명", "대표자", "사업자번호", 
        "업태", "종목", "전화번호", "팩스번호", "우리담당자", 
        "상대방담당자", "상대방담당자전화", "세금계산서우편번호", 
        "세금계산서주소", "배송지우편번호", "배송지주소", "로케이션"
    ]
    
    # 최종 헤더: 기본 + 동적분류 + 기타
    headers = base_headers + classification_headers + [
        "세금담당자", "세금담당자전화", "세금담당자이메일", 
        "매장사용", "비고", "메모", "등록일", "수정일"
    ]
    
    # 두 번째 시트에 분류 코드 정보 추가 (업로드 참조용)
    ws_codes = wb.create_sheet("분류코드정보")
    # 모든 분류 그룹과 하위 코드들을 참조 테이블로 생성
```

### 2. 엑셀 일괄 업로드 API

#### `/shop/api/upload-excel` - 신규 업로드 기능
```python
@shop_bp.route('/api/upload-excel', methods=['POST'])
def api_upload_excel():
    """매장 정보 엑셀 일괄 업로드 API - 동적 분류 완전 지원"""
    
    # 현재 동적 분류 정보 조회
    classifications = {}
    classification_field_map = {}  # 헤더명 -> 필드명 매핑
    
    # CST 하위 분류 그룹들 조회
    for group in classification_groups:
        group_key = group.code.lower()
        field_name = get_field_mapping(group_key)
        
        classifications[group_key] = {
            'field_name': field_name,
            'valid_codes': get_valid_codes(group.seq)  # 유효한 분류 코드/명
        }
        classification_field_map[group.code_name] = field_name
    
    # 엑셀 파일 읽기 및 헤더 분석
    headers = read_excel_headers(file)
    
    # 필수 컬럼 체크
    required_columns = ['거래처코드', '거래처명']
    validate_required_columns(headers, required_columns)
    
    # 행별 데이터 처리
    for row_idx, row_data in enumerate(excel_rows):
        try:
            # 기본 필드 매핑
            update_data = map_basic_fields(row_data)
            
            # 동적 분류 필드 처리
            for header_name, field_name in classification_field_map.items():
                if header_name in row_data:
                    classification_value = row_data[header_name].strip()
                    
                    # 분류 코드 유효성 검증 및 변환
                    validated_code = validate_and_convert_classification(
                        classification_value, 
                        classifications, 
                        header_name
                    )
                    
                    if validated_code:
                        update_data[field_name] = validated_code
                    else:
                        # 유효하지 않은 분류값 오류 기록
                        add_error(f"행 {row_idx}: {header_name}의 값 '{classification_value}'은(는) 유효하지 않습니다.")
            
            # UPSERT 처리
            process_upsert(customer_code, update_data)
            
        except Exception as e:
            add_error(f"행 {row_idx}: {str(e)}")
    
    return {
        'success': True,
        'message': f"업로드 완료: {success_count}개 성공",
        'data': {
            'total_processed': total_count,
            'success_count': success_count,
            'update_count': update_count,
            'insert_count': insert_count,
            'error_count': error_count,
            'error_details': error_details[:10]
        }
    }
```

## 🎨 UI/UX 설계

### 1. 업로드 모달 구성

#### 드래그 앤 드롭 인터페이스
```html
<div class="border-2 border-dashed border-primary rounded p-4 text-center mb-3" 
     id="uploadArea" 
     ondrop="handleDrop(event)" 
     ondragover="handleDragOver(event)">
    <i class="fas fa-cloud-upload-alt fa-3x text-primary mb-3"></i>
    <h5>파일을 여기에 드래그하거나 클릭하여 선택</h5>
    <p class="text-muted">Excel 파일 (.xlsx, .xls)</p>
</div>
```

#### 업로드 안내 정보
```html
<div class="alert alert-info">
    <h6><i class="fas fa-info-circle"></i> 업로드 안내</h6>
    <ul class="mb-0">
        <li><strong>동적 분류 지원:</strong> 현재 설정된 모든 분류 항목 자동 반영</li>
        <li><strong>필수 컬럼:</strong> 거래처코드, 거래처명</li>
        <li><strong>분류 값:</strong> 코드 또는 코드명 모두 입력 가능</li>
        <li><strong>중복 처리:</strong> 기존 거래처는 업데이트, 신규는 추가</li>
        <li><strong>참조 정보:</strong> 다운로드한 엑셀의 "분류코드정보" 시트 참조</li>
    </ul>
</div>
```

### 2. 진행 상황 표시

#### 실시간 진행률
```javascript
// 가짜 진행률 애니메이션
let progress = 0;
const progressInterval = setInterval(() => {
    progress += Math.random() * 15;
    if (progress > 90) progress = 90;
    
    $('#progressBar').css('width', progress + '%');
    $('#progressText').text(Math.round(progress) + '%');
}, 200);
```

#### 상세 결과 리포트
```javascript
// 업로드 완료 후 결과 표시
let resultHtml = `
    <div class="alert alert-success">
        <h6><i class="fas fa-check-circle"></i> 업로드 완료!</h6>
        <div class="row text-center">
            <div class="col-3">
                <div class="card bg-light">
                    <div class="card-body p-2">
                        <h5 class="mb-1 text-primary">${data.total_processed}</h5>
                        <small>총 처리</small>
                    </div>
                </div>
            </div>
            <div class="col-3">
                <div class="card bg-light">
                    <div class="card-body p-2">
                        <h5 class="mb-1 text-success">${data.success_count}</h5>
                        <small>성공</small>
                    </div>
                </div>
            </div>
            <!-- 업데이트, 신규 통계... -->
        </div>
    </div>
`;
```

## 🔄 동적 분류 처리 로직

### 1. 분류 값 유효성 검증

#### 코드/코드명 자동 변환
```python
def validate_and_convert_classification(classification_value, classifications, header_name):
    """분류 값 유효성 검증 및 코드 변환"""
    
    # 분류 그룹 찾기
    group_key = find_group_key_by_header(classifications, header_name)
    if not group_key:
        return None
    
    valid_codes = classifications[group_key]['valid_codes']
    
    # 1. 코드명으로 입력된 경우 -> 코드로 변환
    if classification_value in valid_codes.values():
        for code, name in valid_codes.items():
            if name == classification_value:
                return code
    
    # 2. 이미 코드로 입력된 경우
    elif classification_value in valid_codes:
        return classification_value
    
    # 3. 유효하지 않은 값
    return None
```

### 2. 동적 필드 매핑

#### 레거시 호환성 유지
```python
def get_field_mapping(group_key):
    """그룹 키를 데이터베이스 필드명으로 매핑"""
    
    # 레거시 필드명 매핑
    legacy_mappings = {
        'dis': 'distribution_type',
        'ch': 'channel_type', 
        'sl': 'sales_type',
        'ty': 'business_form'
    }
    
    # 레거시 매핑이 있으면 사용, 없으면 표준 패턴
    return legacy_mappings.get(group_key, f'{group_key}_type')
```

### 3. UPSERT 로직

#### 스마트 데이터 병합
```python
def process_upsert(customer_code, update_data, current_company_id, member_id):
    """고객 데이터 UPSERT 처리"""
    
    # 기존 데이터 찾기
    existing_customer = ErpiaCustomer.query.filter_by(
        customer_code=customer_code,
        company_id=current_company_id
    ).first()
    
    if existing_customer:
        # 기존 데이터 업데이트
        for field, value in update_data.items():
            if hasattr(existing_customer, field):
                setattr(existing_customer, field, value)
        
        existing_customer.upt_user = member_id
        existing_customer.upt_date = datetime.utcnow()
        return 'updated'
        
    else:
        # 신규 데이터 삽입
        new_customer = ErpiaCustomer(
            customer_code=customer_code,
            company_id=current_company_id,
            ins_user=member_id,
            ins_date=datetime.utcnow(),
            upt_user=member_id,
            upt_date=datetime.utcnow(),
            **update_data
        )
        db.session.add(new_customer)
        return 'inserted'
```

## 📊 사용 시나리오

### 시나리오 1: 새 분류 추가 후 업로드
```
1. 관리자가 코드 관리에서 "등급" 분류 추가
   └── CST > GRD (등급) > VIP, REG, NEW

2. 사용자가 엑셀 다운로드
   └── 헤더에 "등급" 컬럼 자동 포함
   └── "분류코드정보" 시트에 등급 코드 정보 포함

3. 엑셀 파일 수정
   └── "등급" 컬럼에 "VIP", "일반고객", "신규고객" 입력

4. 엑셀 업로드
   └── "VIP" -> VIP 코드로 자동 변환
   └── "일반고객" -> REG 코드로 자동 변환
   └── "신규고객" -> NEW 코드로 자동 변환
```

### 시나리오 2: 대량 데이터 업로드
```
1. 1000개 거래처 엑셀 파일 준비
   └── 기본 정보 + 9개 분류 정보 포함

2. 드래그 앤 드롭으로 업로드
   └── 진행률 실시간 표시

3. 처리 결과
   └── 성공 950개 (업데이트 800, 신규 150)
   └── 오류 50개 (분류값 오류 30, 필수값 누락 20)
   └── 상세 오류 내역 표시

4. 오류 수정 후 재업로드
   └── 50개 오류 건만 별도 처리
```

### 시나리오 3: 분류 삭제 후 업로드
```
1. 관리자가 "등급" 분류 삭제
   └── 코드 관리에서 GRD 그룹 삭제

2. 기존 엑셀 템플릿으로 업로드 시도
   └── "등급" 컬럼 무시 (오류 없음)
   └── 다른 데이터는 정상 처리

3. 새 템플릿 다운로드
   └── "등급" 컬럼 자동 제외
   └── 최신 분류 구조 반영
```

## 🛡️ 오류 처리 및 검증

### 1. 파일 검증
- **확장자 체크**: .xlsx, .xls만 허용
- **크기 제한**: 10MB 이하
- **구조 검증**: 필수 컬럼 존재 여부

### 2. 데이터 검증
- **필수 값**: 거래처코드, 거래처명
- **분류 값**: 유효한 코드/코드명만 허용
- **데이터 타입**: 적절한 형식 확인

### 3. 처리 중 오류
- **부분 실패 허용**: 일부 행 오류 시에도 계속 진행
- **롤백 방지**: 성공한 데이터는 보존
- **상세 리포트**: 오류 위치 및 원인 명시

## 🏆 시스템 장점

### 1. 완전 동적 시스템
- **무제한 확장**: 새로운 분류 추가 시 코드 수정 불필요
- **실시간 반영**: 분류 변경 즉시 업로드 지원
- **자동 검증**: 유효하지 않은 분류값 자동 감지

### 2. 사용자 친화적
- **직관적 UI**: 드래그 앤 드롭 인터페이스
- **상세 안내**: 업로드 전 요구사항 명시
- **실시간 피드백**: 진행 상황 및 결과 표시

### 3. 데이터 무결성
- **UPSERT 로직**: 중복 방지 및 데이터 일관성
- **오류 허용**: 부분 실패 시에도 안전한 처리
- **추적 가능**: 모든 변경 이력 기록

### 4. 성능 최적화
- **대용량 지원**: 대량 데이터 효율적 처리
- **메모리 효율**: 스트리밍 방식 파일 읽기
- **타임아웃 관리**: 장시간 작업 안전 처리

## 🔗 관련 파일

### 백엔드
- `app/shop/__init__.py`: 업로드/다운로드 API
- `app/common/models.py`: ErpiaCustomer 모델
- `app/services/erpia_client.py`: ERPia 연동 서비스

### 프론트엔드
- `app/templates/shop/index.html`: 업로드 UI 및 JavaScript
- `app/templates/base.html`: 공통 스타일

### 문서
- `docs/15_동적_분류_관리_시스템.md`: 동적 분류 시스템
- `docs/16_상품정보_동적_분류_확장_설계.md`: 상품 확장 설계

---

**작성일**: 2025-08-07  
**작성자**: MIS v2 개발팀  
**버전**: 1.0 