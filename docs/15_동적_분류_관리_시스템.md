# 동적 분류 관리 시스템

## 📋 개요

MIS v2의 동적 분류 관리 시스템은 코드 관리와 완전히 연동되어 분류 정보의 추가, 수정, 삭제에 실시간으로 대응하는 확장 가능한 시스템입니다.

## 🏗️ 시스템 아키텍처

### 1. 계층 구조
```
CST (거래처) - depth=0
├── DIS (유통 구분) - depth=1
│   ├── RT (소매) - depth=2
│   ├── WH (도매) - depth=2
│   └── ...
├── CH (채널구분) - depth=1
│   ├── ON (온라인) - depth=2
│   ├── OFF (오프라인) - depth=2
│   └── ...
└── [새 분류 그룹] - depth=1
    ├── [새 분류 코드1] - depth=2
    └── [새 분류 코드2] - depth=2
```

### 2. 데이터 모델

#### Code 테이블 구조
```sql
-- 코드 관리 테이블
CREATE TABLE tbl_code (
    seq INTEGER PRIMARY KEY,
    parent_seq INTEGER,     -- 상위 코드 SEQ
    depth INTEGER,          -- 깊이 (0: 최상위, 1: 그룹, 2: 코드)
    sort INTEGER,           -- 정렬 순서
    code VARCHAR(50),       -- 코드
    code_name VARCHAR(100), -- 코드명
    code_info TEXT,         -- 코드 설명
    ins_user VARCHAR(50),
    ins_date TIMESTAMP,
    upt_user VARCHAR(50),
    upt_date TIMESTAMP
);
```

#### ErpiaCustomer 분류 필드
```sql
-- 매장(거래처) 정보의 분류 필드들
distribution_type VARCHAR(50),    -- 유통 (DIS)
channel_type VARCHAR(50),        -- 채널 (CH)
sales_type VARCHAR(50),          -- 매출 (SL)
business_form VARCHAR(50),       -- 매장형태 (TY)
brand_zone VARCHAR(50),          -- 브랜드존 (BZ)
nuna_zoning VARCHAR(50),         -- 뉴나 브랜드 조닝 (NZ)
region VARCHAR(50),              -- 지역 (RG)
financial_group VARCHAR(50),     -- 가결산 구분값 (FG)
-- [추가 분류 필드들이 동적으로 확장 가능]
```

## 🔄 동적 처리 메커니즘

### 1. API 레벨 동적 조회

#### `/shop/api/classifications` - 완전 동적 분류 API
```python
@shop_bp.route('/api/classifications')
def api_get_classifications():
    """매장 분류정보 조회 API - CST 코드 관리와 완전 연동"""
    try:
        classifications = {}
        
        # CST 그룹 찾기
        cst_group = Code.query.filter_by(code='CST', depth=0).first()
        if not cst_group:
            return jsonify({'success': True, 'data': {}})
        
        # CST 하위의 모든 분류 그룹들을 동적으로 조회 (depth=1)
        classification_groups = Code.query.filter_by(
            parent_seq=cst_group.seq, 
            depth=1
        ).order_by(Code.sort.asc()).all()
        
        for group in classification_groups:
            # 각 분류 그룹의 하위 코드들 조회 (depth=2)
            sub_codes = Code.query.filter_by(
                parent_seq=group.seq,
                depth=2
            ).order_by(Code.sort.asc()).all()
            
            # 분류 그룹 키는 소문자로 통일
            group_key = group.code.lower()
            classifications[group_key] = {
                'group_info': {
                    'code': group.code,
                    'name': group.code_name,
                    'seq': group.seq,
                    'sort': group.sort
                },
                'codes': [code.to_dict() for code in sub_codes]
            }
        
        return jsonify({
            'success': True,
            'data': classifications,
            'meta': {
                'total_groups': len(classification_groups),
                'cst_group': {'seq': cst_group.seq, 'name': cst_group.code_name},
                'last_updated': datetime.utcnow().isoformat()
            }
        })
        
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500
```

### 2. UI 레벨 동적 생성

#### JavaScript 동적 UI 구성
```javascript
// 분류 UI 동적 생성
function buildClassificationUI() {
    const container = $('#classificationsContainer');
    
    // 분류 그룹이 없을 때 안내 메시지
    if (!classificationGroups || classificationGroups.length === 0) {
        container.html(`
            <div class="col-12 text-center text-muted">
                <i class="fas fa-info-circle"></i> 사용 가능한 분류 정보가 없습니다.
                <br><small>코드 관리에서 CST 그룹에 분류를 추가해주세요.</small>
            </div>
        `);
        return;
    }
    
    let html = '';
    
    // 분류 그룹별로 드롭다운 생성 (2열 레이아웃)
    classificationGroups.forEach(function(group, index) {
        const fieldId = group.key; // 소문자 키 사용
        const fieldName = group.name;
        
        html += `
            <div class="col-md-6 mb-3">
                <label for="${fieldId}" class="form-label">
                    <i class="fas fa-tag text-primary"></i> ${fieldName}
                    <small class="text-muted">(${group.sub_codes_count}개 옵션)</small>
                </label>
                <select class="form-control classification-select" 
                        id="${fieldId}" 
                        data-group-code="${group.code}"
                        data-group-seq="${group.seq}">
                    <option value="">선택하세요</option>
                </select>
            </div>
        `;
    });
    
    container.html(html);
    console.log(`🎨 분류 UI 생성 완료: ${classificationGroups.length}개 드롭다운`);
}

// 분류 드롭다운 옵션 채우기
function populateClassificationDropdowns() {
    classificationGroups.forEach(function(group) {
        const selectElement = $(`#${group.key}`);
        if (selectElement.length === 0) return;
        
        // 기존 옵션 제거 (첫 번째 "선택하세요" 제외)
        selectElement.find('option:not(:first)').remove();
        
        // 해당 그룹의 분류 정보 가져오기
        const classificationData = shopClassifications[group.key];
        if (!classificationData || !classificationData.codes) {
            console.warn(`⚠️ ${group.key} 분류 데이터 없음`);
            return;
        }
        
        // 옵션 추가
        classificationData.codes.forEach(function(code) {
            selectElement.append(`
                <option value="${code.code}" title="${code.code_info || code.code_name}">
                    ${code.code_name}
                </option>
            `);
        });
    });
}
```

### 3. 데이터 저장 시 동적 처리

#### 매장 정보 수정 API
```python
@shop_bp.route('/api/shop/<int:shop_seq>', methods=['PUT'])
def api_update_shop(shop_seq):
    """매장 정보 수정 API - 동적 필드 지원"""
    try:
        # 수정 가능한 필드들 동적 조회
        from sqlalchemy import inspect
        mapper = inspect(ErpiaCustomer)
        updatable_fields = []
        
        exclude_fields = {
            'seq', 'company_id', 'customer_code', 'ins_user', 'ins_date', 'upt_user', 'upt_date'
        }
        
        for column in mapper.columns:
            field_name = column.name
            if field_name not in exclude_fields:
                updatable_fields.append(field_name)
        
        data = request.get_json()
        
        # 데이터에서 수정 가능한 필드들만 업데이트
        for field in updatable_fields:
            if field in data:
                setattr(shop, field, data[field])
        
        # 수정 정보 업데이트
        shop.upt_user = member_id
        shop.upt_date = datetime.utcnow()
        
        db.session.commit()
        
        return jsonify({
            'success': True,
            'message': '매장 정보가 수정되었습니다.',
            'data': shop.to_dict()
        })
        
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'message': str(e)}), 500
```

## 🔧 분류 추가/삭제 시나리오

### 1. 새 분류 추가 시

#### Step 1: 코드 관리에서 추가
```sql
-- 1. 새 분류 그룹 추가 (예: 고객등급)
INSERT INTO tbl_code (parent_seq, depth, sort, code, code_name, code_info)
VALUES (334, 1, 10, 'GRD', '고객등급', '고객 등급 분류');

-- 2. 하위 분류 코드들 추가
INSERT INTO tbl_code (parent_seq, depth, sort, code, code_name)
VALUES 
(새그룹seq, 2, 1, 'VIP', 'VIP 고객'),
(새그룹seq, 2, 2, 'REG', '일반 고객'),
(새그룹seq, 2, 3, 'NEW', '신규 고객');
```

#### Step 2: 자동 반영 과정
```
코드 관리에서 분류 추가
        ↓
/shop/api/classifications API 호출 시 자동 감지
        ↓
UI에서 새 드롭다운 자동 생성
        ↓
매장 데이터 저장 시 새 필드 지원
        ↓
기존 매장들은 새 분류 NULL 상태로 유지
```

### 2. 분류 삭제 시

#### Step 1: 코드 관리에서 삭제
```sql
-- 하위 코드들 먼저 삭제
DELETE FROM tbl_code WHERE parent_seq = 삭제할그룹seq;

-- 분류 그룹 삭제
DELETE FROM tbl_code WHERE seq = 삭제할그룹seq;
```

#### Step 2: 안전한 처리
```
코드 관리에서 분류 삭제
        ↓
/shop/api/classifications API에서 해당 분류 제외
        ↓
UI에서 해당 드롭다운 자동 제거
        ↓
기존 매장 데이터의 해당 필드는 보존 (NULL)
        ↓
새 매장 등록 시 해당 분류 입력 불가
```

## 📊 테스트 결과

### 현재 분류 그룹 (9개)
- `DIS(유통 구분)`: 9개 하위 코드
- `CH(채널구분)`: 20개 하위 코드  
- `SL(매출 구분)`: 58개 하위 코드
- `TY(형태 구분)`: 538개 하위 코드
- `BZ(브랜드존)`: 7개 하위 코드
- `NZ(뉴나 브랜드 조닝)`: 2개 하위 코드
- `RG(지역)`: 19개 하위 코드
- `FG(가결산 구분값)`: 23개 하위 코드
- `GRD(등급 구분)`: 0개 하위 코드 (테스트용)

### 동적 대응 검증
✅ **새 분류 추가**: 즉시 API 반영, UI 자동 생성  
✅ **분류 삭제**: 안전한 제거, 기존 데이터 보존  
✅ **실시간 변경**: 코드 변경 시 즉시 매장 관리에 반영  
✅ **무제한 확장**: 분류 그룹/옵션 개수 제한 없음  

## 🚀 상품정보 확장 적용 계획

### 1. 상품 분류 체계 설계
```
PRD (상품) - depth=0
├── CAT (카테고리) - depth=1
│   ├── TOP (상의) - depth=2
│   ├── BOT (하의) - depth=2
│   └── ACC (액세서리) - depth=2
├── BRD (브랜드) - depth=1
│   ├── NIKE (나이키) - depth=2
│   ├── ADIDAS (아디다스) - depth=2
│   └── ...
├── SZE (사이즈) - depth=1
│   ├── XS (엑스스몰) - depth=2
│   ├── S (스몰) - depth=2
│   └── ...
└── [확장 분류] - depth=1
```

### 2. 상품 모델 확장
```python
class ErpiaProduct(db.Model):
    """ERPia 상품 정보 모델"""
    __tablename__ = 'erpia_product'
    
    # 기본 정보
    seq = db.Column(db.Integer, primary_key=True)
    product_code = db.Column(db.String(50), index=True)
    product_name = db.Column(db.String(200))
    # ... ERPia 기본 필드들
    
    # 동적 분류 필드들 (PRD 그룹)
    category_type = db.Column(db.String(50))     # 카테고리 (CAT)
    brand_type = db.Column(db.String(50))        # 브랜드 (BRD)
    size_type = db.Column(db.String(50))         # 사이즈 (SZE)
    color_type = db.Column(db.String(50))        # 색상 (COL)
    material_type = db.Column(db.String(50))     # 소재 (MAT)
    season_type = db.Column(db.String(50))       # 시즌 (SEA)
    # [추가 분류 필드들이 동적으로 확장 가능]
```

### 3. 상품 관리 API 구조
```python
@product_bp.route('/api/classifications')
def api_get_product_classifications():
    """상품 분류정보 조회 API - PRD 코드 관리와 완전 연동"""
    # PRD 그룹 하위의 모든 분류들을 동적으로 조회
    # 매장 관리와 동일한 구조로 구현
    
@product_bp.route('/api/product/<int:product_seq>', methods=['PUT'])
def api_update_product(product_seq):
    """상품 정보 수정 API - 동적 필드 지원"""
    # ErpiaCustomer와 동일한 동적 필드 처리 로직 적용
```

## 🏆 핵심 장점

### 1. 완전 동적 시스템
- **하드코딩 없음**: 모든 분류가 DB 기반으로 관리
- **실시간 반영**: 코드 변경 시 즉시 UI 업데이트
- **무제한 확장**: 분류 그룹/옵션 개수 제한 없음

### 2. 안전성
- **기존 데이터 보존**: 분류 삭제 시 기존 데이터 유지
- **오류 방지**: 존재하지 않는 분류 선택 불가
- **트랜잭션 안전**: DB 무결성 보장

### 3. 사용자 친화적
- **직관적 UI**: 자동 생성되는 드롭다운 인터페이스
- **안내 메시지**: 분류 없을 때 가이드 제공
- **관리 연동**: 코드 관리 페이지로 직접 링크

### 4. 멀티테넌트 지원
- **회사별 독립**: 에이원/에이원월드 분리 관리
- **권한 기반**: 회사별 접근 제어
- **데이터 격리**: 완전한 데이터 분리

## 📝 구현 가이드

### 1. 새 분류 체계 추가 시
1. **코드 관리**: CST 하위에 새 그룹 생성
2. **하위 코드**: 필요한 분류 옵션들 추가
3. **자동 반영**: 매장 관리에서 즉시 확인 가능

### 2. 상품정보 확장 시
1. **PRD 그룹**: 코드 관리에 PRD 최상위 그룹 생성
2. **상품 분류**: PRD 하위에 필요한 분류 그룹들 추가
3. **API 개발**: 매장 관리와 동일한 패턴으로 구현
4. **UI 구성**: 동적 분류 시스템 재사용

### 3. 유지보수
- **정기 점검**: 사용하지 않는 분류 정리
- **성능 모니터링**: 분류 개수 증가에 따른 성능 체크
- **사용자 교육**: 분류 관리 방법 안내

## 🔗 관련 파일

### 백엔드
- `app/shop/__init__.py`: 매장 관리 API
- `app/admin/__init__.py`: 코드 관리 API
- `app/common/models.py`: 데이터 모델
- `app/services/erpia_client.py`: ERPia 연동

### 프론트엔드
- `app/templates/shop/index.html`: 매장 관리 UI
- `app/templates/admin/code_management.html`: 코드 관리 UI

### 문서
- `docs/13_내일_할일_우선순위.md`: 작업 우선순위
- `docs/14_UI_UX_기본_요구사항.md`: UI/UX 요구사항

---

**작성일**: 2025-08-07  
**작성자**: MIS v2 개발팀  
**버전**: 1.0 